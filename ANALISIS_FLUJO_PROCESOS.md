# An√°lisis Detallado del Flujo de Procesos - ProcessFlowControlService.js

## üìã Resumen Ejecutivo

Este documento analiza exhaustivamente el flujo de procesos implementado en `ProcessFlowControlService.js` y su sincronizaci√≥n con `index.js` durante la inicializaci√≥n del sistema TV IPTV Addon para Stremio.

### Hallazgos Principales

1. **ProcessFlowControlService NO se integra directamente con index.js**
2. **Integraci√≥n indirecta a trav√©s de servicios especializados**
3. **Control de flujo din√°mico basado en recursos del sistema**
4. **Arquitectura event-driven para throttling autom√°tico**

---

## üèóÔ∏è Arquitectura del Sistema de Control de Flujo

### 1. Ubicaci√≥n y Prop√≥sito del ProcessFlowControlService

```
src/infrastructure/services/ProcessFlowControlService.js
```

**Prop√≥sito Principal**: Prevenir sobrecarga del proceso principal mediante throttling din√°mico basado en recursos del sistema (memoria y CPU).

**Caracter√≠sticas Clave**:
- Control de concurrencia din√°mico
- Monitoreo de recursos en tiempo real
- Arquitectura basada en eventos (EventEmitter)
- Throttling autom√°tico cuando se exceden umbrales

### 2. Integraci√≥n Indirecta con index.js

**ProcessFlowControlService NO es instanciado directamente en index.js**. Su integraci√≥n ocurre a trav√©s de:

1. **StreamValidationService** (l√≠neas 35-50)
2. **HttpsToHttpConversionService** (l√≠neas 35-58)

Estos servicios son inicializados indirectamente durante el proceso de inicializaci√≥n del addon.

---

## üîÑ Secuencia de Inicializaci√≥n Completa

### Fase 1: Inicializaci√≥n Principal (index.js)

```javascript
class TVIPTVAddon {
  async initialize() {
    // 1. Configuraci√≥n base
    this.#logger.info('Configuraci√≥n cargada:', this.#config.toJSON());
    
    // 2. Inicializaci√≥n de repositorios
    await this.#initializeChannelRepository();
    
    // 3. Inicializaci√≥n de servicios (AQU√ç se integra ProcessFlowControlService)
    await this.#initializeServices();
    
    // 4. Construcci√≥n del addon
    this.#createAddonBuilder();
    
    // 5. Configuraci√≥n de handlers
    this.#configureHandlers();
    
    // 6. Validaci√≥n inicial (opcional)
    if (this.#config.validation.validateStreamsOnStartup) {
      await this.#validateStreamsOnStartup();
    }
  }
}
```

### Fase 2: Inicializaci√≥n de Servicios

Durante `#initializeServices()`, se crean servicios que internamente instancian `ProcessFlowControlService`:

#### 2.1 StreamValidationService
```javascript
// En StreamValidationService.js (l√≠neas 35-50)
this.#flowControlService = new ProcessFlowControlService(logger, {
  memoryThreshold: config.MEMORY_USAGE_THRESHOLD || 70,
  cpuThreshold: 80,
  checkInterval: 5000,
  minConcurrency: 1,
  maxConcurrency: config.STREAM_VALIDATION_GENERAL_CONCURRENCY || 5
});
```

#### 2.2 HttpsToHttpConversionService
```javascript
// En HttpsToHttpConversionService.js (l√≠neas 35-58)
this.#flowControlService = new ProcessFlowControlService(logger, {
  memoryThreshold: config.MEMORY_USAGE_THRESHOLD || 70,
  cpuThreshold: 80,
  checkInterval: 3000,
  minConcurrency: 1,
  maxConcurrency: config.HTTPS_TO_HTTP_CONCURRENCY || 3
});
```

### Fase 3: Configuraci√≥n de Event Listeners

Cada servicio configura listeners para eventos de throttling:

```javascript
// Eventos de throttling
this.#flowControlService.on('throttlingStarted', (data) => {
  this.#logger.warn(`üö® Throttling activado - Reduciendo concurrencia a ${data.newConcurrency}`);
});

this.#flowControlService.on('throttlingStopped', (data) => {
  this.#logger.info(`‚úÖ Throttling desactivado - Concurrencia restaurada a ${data.newConcurrency}`);
});
```

---

## üîó Dependencias Jer√°rquicas entre Componentes

### Nivel 1: N√∫cleo del Sistema
```
index.js (TVIPTVAddon)
‚îú‚îÄ‚îÄ TVAddonConfig
‚îú‚îÄ‚îÄ EnhancedLoggerService
‚îú‚îÄ‚îÄ ErrorHandler
‚îî‚îÄ‚îÄ SecurityMiddleware
```

### Nivel 2: Repositorios y Servicios Base
```
TVIPTVAddon
‚îú‚îÄ‚îÄ ChannelRepository (Factory)
‚îÇ   ‚îú‚îÄ‚îÄ RemoteM3UChannelRepository
‚îÇ   ‚îú‚îÄ‚îÄ HybridChannelRepository
‚îÇ   ‚îî‚îÄ‚îÄ AutomaticChannelRepository
‚îú‚îÄ‚îÄ StreamHealthService
‚îî‚îÄ‚îÄ InvalidChannelManagementService
```

### Nivel 3: Servicios Especializados (CON ProcessFlowControlService)
```
ChannelRepository
‚îú‚îÄ‚îÄ StreamValidationService
‚îÇ   ‚îú‚îÄ‚îÄ ProcessFlowControlService ‚≠ê
‚îÇ   ‚îú‚îÄ‚îÄ HttpsToHttpConversionService
‚îÇ   ‚îî‚îÄ‚îÄ StreamHealthService
‚îî‚îÄ‚îÄ HttpsToHttpConversionService
    ‚îú‚îÄ‚îÄ ProcessFlowControlService ‚≠ê
    ‚îî‚îÄ‚îÄ StreamHealthService
```

### Nivel 4: Handlers de Aplicaci√≥n
```
TVIPTVAddon
‚îî‚îÄ‚îÄ StreamHandler
    ‚îî‚îÄ‚îÄ ChannelService (Repository)
```

---

## ‚öôÔ∏è Mecanismos de Control y Supervisi√≥n

### 1. Control de Concurrencia Din√°mico

**ProcessFlowControlService** implementa un sistema de control de concurrencia que se adapta autom√°ticamente:

```javascript
// Configuraci√≥n t√≠pica
{
  memoryThreshold: 70,    // 70% de memoria
  cpuThreshold: 80,       // 80% de CPU
  checkInterval: 3000,    // Verificar cada 3s
  minConcurrency: 1,      // M√≠nimo 1 operaci√≥n
  maxConcurrency: 5       // M√°ximo 5 operaciones
}
```

### 2. Monitoreo de Recursos

**M√©tricas Monitoreadas**:
- **Uso de Memoria**: Porcentaje de memoria utilizada
- **Uso de CPU**: Porcentaje de CPU utilizada
- **Concurrencia Actual**: N√∫mero de operaciones activas

**Algoritmo de Throttling**:
```javascript
if (memoryUsage > memoryThreshold || cpuUsage > cpuThreshold) {
  // Reducir concurrencia gradualmente
  newConcurrency = Math.max(minConcurrency, currentConcurrency - 1);
  emit('throttlingStarted', { newConcurrency });
} else {
  // Restaurar concurrencia gradualmente
  newConcurrency = Math.min(maxConcurrency, currentConcurrency + 1);
  emit('throttlingStopped', { newConcurrency });
}
```

### 3. Gesti√≥n de Operaciones

**Patr√≥n Request/Release**:
```javascript
// Solicitar permiso para procesar
await this.#flowControlService.requestOperation(`worker-${workerId}`);

try {
  // Procesar operaci√≥n
  const result = await this.processChannel(channel);
} finally {
  // Liberar operaci√≥n
  this.#flowControlService.releaseOperation(`worker-${workerId}`);
}
```

---

## üîÑ Puntos de Interacci√≥n Cr√≠ticos

### 1. StreamValidationService ‚Üî ProcessFlowControlService

**Ubicaci√≥n**: `src/infrastructure/services/StreamValidationService.js`

**Interacciones**:
- **Inicializaci√≥n**: L√≠neas 35-50
- **Control de Workers**: M√©todo `#processBatch` (l√≠neas 300-350)
- **Gesti√≥n de Concurrencia**: Durante validaci√≥n por lotes

**Flujo de Control**:
```javascript
const worker = async (workerId) => {
  while (queue.length > 0) {
    // 1. Solicitar permiso
    await this.#flowControlService.requestOperation(`worker-${workerId}`);
    
    const channel = queue.shift();
    if (!channel) {
      this.#flowControlService.releaseOperation(`worker-${workerId}`);
      break;
    }

    try {
      // 2. Procesar canal
      const result = await this.validateChannel(channel);
      results.push(result);
    } finally {
      // 3. Liberar operaci√≥n
      this.#flowControlService.releaseOperation(`worker-${workerId}`);
    }
  }
};
```

### 2. HttpsToHttpConversionService ‚Üî ProcessFlowControlService

**Ubicaci√≥n**: `src/infrastructure/services/HttpsToHttpConversionService.js`

**Interacciones**:
- **Inicializaci√≥n**: L√≠neas 35-58
- **Control de Workers**: M√©todo `processChannels` (l√≠neas 170-220)
- **Monitoreo de Progreso**: Incluye m√©tricas de concurrencia en logs

**Flujo de Control**:
```javascript
const worker = async (workerId) => {
  while (queue.length > 0) {
    // 1. Solicitar permiso para procesar
    await this.#flowControlService.requestOperation(`worker-${workerId}`);
    
    const channel = queue.shift();
    if (!channel) {
      this.#flowControlService.releaseOperation(`worker-${workerId}`);
      break;
    }

    try {
      // 2. Procesar conversi√≥n HTTPS‚ÜíHTTP
      const result = await this.processChannel(channel);
      
      // 3. Mostrar progreso con m√©tricas de flujo
      if (showProgress && (completed % 50 === 0 || completed === total)) {
        const flowStats = this.#flowControlService.getStats();
        this.#logger.info(
          formatProgressMessage(completed, total, stats.httpWorking) + 
          ` [Concurrencia: ${flowStats.currentConcurrency}, Memoria: ${flowStats.memoryUsage.toFixed(1)}%]`
        );
      }
    } finally {
      // 4. Liberar operaci√≥n
      this.#flowControlService.releaseOperation(`worker-${workerId}`);
    }
  }
};
```

---

## üõ°Ô∏è Controles de Fallos durante el Arranque

### 1. Manejo de Errores en index.js

```javascript
async initialize() {
  try {
    // Secuencia de inicializaci√≥n
    await this.#initializeChannelRepository();
    await this.#initializeServices();
    // ...
  } catch (error) {
    this.#logger.error('Error inicializando addon:', error);
    throw error; // Re-lanzar para manejo superior
  }
}
```

### 2. Manejo de Errores en main()

```javascript
async function main() {
  try {
    const addon = new TVIPTVAddon();
    await addon.start();
  } catch (error) {
    console.error('üí• Error fatal durante el arranque:', error.message);
    
    if (process.env.NODE_ENV === 'development') {
      console.error('Stack trace:', error.stack);
    }
    
    process.exit(1); // Salida controlada
  }
}
```

### 3. Controles de ProcessFlowControlService

**Validaci√≥n de Configuraci√≥n**:
```javascript
#validateConfig(config) {
  if (config.memoryThreshold < 10 || config.memoryThreshold > 95) {
    throw new Error('Memory threshold debe estar entre 10% y 95%');
  }
  // M√°s validaciones...
}
```

**Manejo de Errores de Monitoreo**:
```javascript
#checkSystemResources() {
  try {
    const memoryUsage = this.#getMemoryUsage();
    const cpuUsage = this.#getCpuUsage();
    // Procesar m√©tricas...
  } catch (error) {
    this.#logger.warn('Error obteniendo m√©tricas del sistema:', error.message);
    // Continuar sin throttling si no se pueden obtener m√©tricas
  }
}
```

---

## üìä Diagrama de Flujo de Inicializaci√≥n

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   index.js      ‚îÇ
‚îÇ  TVIPTVAddon    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ initialize()    ‚îÇ
‚îÇ 1. Config       ‚îÇ
‚îÇ 2. Repository   ‚îÇ
‚îÇ 3. Services ‚óÑ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Builder      ‚îÇ                                 ‚îÇ
‚îÇ 5. Handlers     ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
          ‚îÇ                                         ‚îÇ
          ‚ñº                                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                 ‚îÇ
‚îÇ#initializeServices                                ‚îÇ
‚îÇ                 ‚îÇ                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 ‚îÇ
          ‚îÇ                                         ‚îÇ
          ‚ñº                                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇChannelRepository‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇStreamValidation ‚îÇ        ‚îÇ
‚îÇ   Factory       ‚îÇ     ‚îÇ    Service      ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
                                  ‚îÇ                ‚îÇ
                                  ‚ñº                ‚îÇ
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
                        ‚îÇProcessFlowControl‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îÇ    Service      ‚îÇ
                        ‚îÇ                 ‚îÇ
                        ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                        ‚îÇ ‚îÇMemory/CPU   ‚îÇ ‚îÇ
                        ‚îÇ ‚îÇMonitoring   ‚îÇ ‚îÇ
                        ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                        ‚îÇ                 ‚îÇ
                        ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                        ‚îÇ ‚îÇThrottling   ‚îÇ ‚îÇ
                        ‚îÇ ‚îÇControl      ‚îÇ ‚îÇ
                        ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìà Diagrama de Flujo de Control de Concurrencia

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Worker Pool    ‚îÇ
‚îÇ                 ‚îÇ
‚îÇ Worker 1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Worker 2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Worker N ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
                        ‚îÇ
                        ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇProcessFlowControl‚îÇ
              ‚îÇ    Service      ‚îÇ
              ‚îÇ                 ‚îÇ
              ‚îÇ requestOperation‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ releaseOperation‚îÇ      ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
                        ‚îÇ              ‚îÇ
                        ‚ñº              ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
              ‚îÇSystem Resources ‚îÇ      ‚îÇ
              ‚îÇ   Monitoring    ‚îÇ      ‚îÇ
              ‚îÇ                 ‚îÇ      ‚îÇ
              ‚îÇ Memory: 65%     ‚îÇ      ‚îÇ
              ‚îÇ CPU: 45%        ‚îÇ      ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
                        ‚îÇ              ‚îÇ
                        ‚ñº              ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
              ‚îÇThrottling Logic ‚îÇ      ‚îÇ
              ‚îÇ                 ‚îÇ      ‚îÇ
              ‚îÇ if > threshold  ‚îÇ      ‚îÇ
              ‚îÇ   reduce        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ else            ‚îÇ
              ‚îÇ   increase      ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üéØ Conclusiones y Recomendaciones

### Hallazgos Clave

1. **Integraci√≥n Indirecta**: ProcessFlowControlService no se integra directamente con index.js, sino a trav√©s de servicios especializados.

2. **Control Autom√°tico**: El sistema implementa throttling autom√°tico basado en recursos del sistema.

3. **Arquitectura Resiliente**: M√∫ltiples capas de manejo de errores garantizan estabilidad.

4. **Monitoreo en Tiempo Real**: M√©tricas de sistema se monitore√°n continuamente.

### Puntos de Mejora Identificados

1. **Centralizaci√≥n**: Considerar un ProcessFlowControlService centralizado en lugar de m√∫ltiples instancias.

2. **Configuraci√≥n**: Unificar configuraci√≥n de thresholds en un solo lugar.

3. **M√©tricas**: Implementar dashboard de m√©tricas para monitoreo visual.

### Estabilidad del Sistema

‚úÖ **Garantizada** a trav√©s de:
- Control de concurrencia din√°mico
- Monitoreo de recursos en tiempo real
- Manejo robusto de errores
- Throttling autom√°tico preventivo
- Arquitectura event-driven resiliente

---

## üìö Referencias T√©cnicas

- **ProcessFlowControlService.js**: Control de flujo principal
- **StreamValidationService.js**: Validaci√≥n con control de flujo
- **HttpsToHttpConversionService.js**: Conversi√≥n con control de flujo
- **index.js**: Inicializaci√≥n principal del sistema
- **EventEmitter Pattern**: Arquitectura basada en eventos
- **Resource Monitoring**: Monitoreo de memoria y CPU

---

*Documento generado el: $(date)*
*Versi√≥n del sistema analizada: TV IPTV Addon v1.0*